<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Assembler on Just a memo</title>
    <link>https://0xAX.github.io/categories/assembler/</link>
    <description>Recent content in Assembler on Just a memo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 13 Jul 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://0xAX.github.io/categories/assembler/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title> Layout of a stack frame in x86_64 </title>
      <link>https://0xAX.github.io/stack_layout_x86_64/</link>
      <pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://0xAX.github.io/stack_layout_x86_64/</guid>
      <description> Stack frame in x86_64 Just for a memo:
 +--------------+ | | + | | | +--------------+ | | | | | arg(N-1) | starts from 7&#39;th argument for x86_64 | | | | +--------------+ | | | | | argN | | | | | +--------------+ | | | | |Return address| %rbp + 8 Stack grows down | | | | +--------------+ | | | | | %rbp | Frame base pointer | | | | +--------------+ | | | | | local var1 | %rbp - 8 | | | | +--------------+ | | | | | local ^ar 2 | &amp;lt;-- %rsp | | | v +--------------+ | | | | +--------------+  </description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 8]</title>
      <link>https://0xAX.github.io/asm_8/</link>
      <pubDate>Mon, 01 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://0xAX.github.io/asm_8/</guid>
      <description>It is eight and final part of Say hello to x86_64 Assembly and here we will take a look on how to work with non-integer numbers in assembler. There are a couple of ways how to work with floating point data:
 fpu sse  First of all let&amp;rsquo;s look how floating point number stored in memory. There are three floating point data types:
 single-precision double-precision double-extended precision  As Intel&amp;rsquo;s 64-ia-32-architecture-software-developer-vol-1-manual described:</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 7]</title>
      <link>https://0xAX.github.io/asm_7/</link>
      <pubDate>Fri, 10 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://0xAX.github.io/asm_7/</guid>
      <description>It is seventh part of Say hello to x86_64 Assembly and here we will look on how we can use C together with assembler.
Actually we have 3 ways to use it together:
 Call assembly routines from C code Call c routines from assembly code Use inline assembly in C code  Let&amp;rsquo;s write 3 simple Hello world programs which shows us how to use assembly and C together.</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 6]</title>
      <link>https://0xAX.github.io/asm_6/</link>
      <pubDate>Wed, 01 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://0xAX.github.io/asm_6/</guid>
      <description>It is sixth part of Say hello to x86_64 Assembly and here we will look on AT&amp;amp;T assembler syntax. Previously we used nasm assembler in all parts, but there are some another assemblers with different syntax, fasm, yasm and others. As i wrote above we will look on gas (GNU assembler) and difference between it&amp;rsquo;s syntax and nasm. GCC uses GNU assembler, so if you see at assembler output for simple hello world:</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 5]</title>
      <link>https://0xAX.github.io/asm_5/</link>
      <pubDate>Sat, 20 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://0xAX.github.io/asm_5/</guid>
      <description>It is a fifth part of Say hello to x86_64 Assembly and here we will look at macros. It will not be blog post about x86_64, mainly it will be about nasm assembler and it&amp;rsquo;s preprocessor. If you&amp;rsquo;re interesting in it read next.
Macros NASM supports two form of macro:
 single-line multiline  All single-line macro must start from %define directive. It form is following:
%define macro_name(parameter) value  Nasm macro behaves and looks very similar as in C.</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 4]</title>
      <link>https://0xAX.github.io/asm_4/</link>
      <pubDate>Mon, 01 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://0xAX.github.io/asm_4/</guid>
      <description>Some time ago i started to write series of blog posts about assembly programming for x86_64. You can find it by asm tag. Unfortunately i was busy last time and there were not new post, so today I continue to write posts about assembly, and will try to do it every week.
Today we will look at strings and some strings operations. We still use nasm assembler, and linux x86_64.</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 3]</title>
      <link>https://0xAX.github.io/asm_3/</link>
      <pubDate>Fri, 15 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://0xAX.github.io/asm_3/</guid>
      <description>The stack is special region in memory, which operates on the principle lifo (Last Input, First Output).
We have 16 general-purpose registers for temporary data storage. They are RAX, RBX, RCX, RDX, RDI, RSI, RBP, RSP and R8-R15. It&amp;rsquo;s too few for serious applications. So we can store data in the stack. Yet another usage of stack is following: When we call a function, return address copied in stack. After end of function execution, address copied in commands counter (RIP) and application continue to executes from next place after function.</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 2]</title>
      <link>https://0xAX.github.io/asm_2/</link>
      <pubDate>Sun, 10 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://0xAX.github.io/asm_2/</guid>
      <description>Some days ago I wrote the first blog post - introduction to x64 assembly - Say hello to x64 Assembly [part 1] which to my surprise caused great interest:
It motivates me even more to describe my way of learning. During this days I got many feedback from different people. There were many grateful words, but what is more important for me, there were many advices and adequate critics. Especially I want to say thank you words for great feedback to:</description>
    </item>
    
    <item>
      <title>Say hello to x86_64 Assembly [part 1]</title>
      <link>https://0xAX.github.io/asm_1/</link>
      <pubDate>Fri, 01 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://0xAX.github.io/asm_1/</guid>
      <description>Introduction There are many developers between us. We write a tons of code every day. Sometime, it is even not a bad code :) Every of us can easily write the simplest code like this:
#include &amp;lt;stdio.h&amp;gt; int main() { int x = 10; int y = 100; printf(&amp;quot;x + y = %d&amp;quot;, x + y); return 0; }  Every of us can understand what&amp;rsquo;s this C code does.</description>
    </item>
    
  </channel>
</rss>